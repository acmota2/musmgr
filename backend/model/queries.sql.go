// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package model

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :exec
insert into events (id, event_date, description, event_type_id)
values ($1, $2, $3, $4)
`

type CreateEventParams struct {
	ID          uuid.UUID   `json:"id"`
	EventDate   pgtype.Date `json:"event_date"`
	Description pgtype.Text `json:"description"`
	EventTypeID uuid.UUID   `json:"event_type_id"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.EventDate,
		arg.Description,
		arg.EventTypeID,
	)
	return err
}

const createFile = `-- name: CreateFile :exec
insert into files (id, name, file_content, file_type, song_id)
values ($1, $2, $3, $4, $5)
`

type CreateFileParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	FileContent []byte    `json:"file_content"`
	FileType    FileType  `json:"file_type"`
	SongID      uuid.UUID `json:"song_id"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) error {
	_, err := q.db.Exec(ctx, createFile,
		arg.ID,
		arg.Name,
		arg.FileContent,
		arg.FileType,
		arg.SongID,
	)
	return err
}

const createSong = `-- name: CreateSong :exec
insert into songs (id, name, tonality_root, tonality_details, subcategory_id)
values ($1, $2, $3, $4, $5)
`

type CreateSongParams struct {
	ID              uuid.UUID `json:"id"`
	Name            string    `json:"name"`
	TonalityRoot    int32     `json:"tonality_root"`
	TonalityDetails string    `json:"tonality_details"`
	SubcategoryID   string    `json:"subcategory_id"`
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) error {
	_, err := q.db.Exec(ctx, createSong,
		arg.ID,
		arg.Name,
		arg.TonalityRoot,
		arg.TonalityDetails,
		arg.SubcategoryID,
	)
	return err
}

const createSongEvent = `-- name: CreateSongEvent :exec
insert into songs_events (song_id, event_id)
values ($1, $2)
`

type CreateSongEventParams struct {
	SongID  uuid.UUID `json:"song_id"`
	EventID uuid.UUID `json:"event_id"`
}

func (q *Queries) CreateSongEvent(ctx context.Context, arg CreateSongEventParams) error {
	_, err := q.db.Exec(ctx, createSongEvent, arg.SongID, arg.EventID)
	return err
}

const createSubcategory = `-- name: CreateSubcategory :exec
insert into subcategories (id, name, category_id)
values ($1, $2, $3)
`

type CreateSubcategoryParams struct {
	ID         uuid.UUID `json:"id"`
	Name       string    `json:"name"`
	CategoryID uuid.UUID `json:"category_id"`
}

func (q *Queries) CreateSubcategory(ctx context.Context, arg CreateSubcategoryParams) error {
	_, err := q.db.Exec(ctx, createSubcategory, arg.ID, arg.Name, arg.CategoryID)
	return err
}

const getCategories = `-- name: GetCategories :many
select id, name, description from categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategorySubcategories = `-- name: GetCategorySubcategories :many
select id, name, category_id from subcategories
where category_id = $1
`

func (q *Queries) GetCategorySubcategories(ctx context.Context, categoryID uuid.UUID) ([]Subcategory, error) {
	rows, err := q.db.Query(ctx, getCategorySubcategories, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subcategory
	for rows.Next() {
		var i Subcategory
		if err := rows.Scan(&i.ID, &i.Name, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventSongs = `-- name: GetEventSongs :many
select id, name, tonality_root, tonality_details, subcategory_id from songs
inner join songs_events
on songs.id = songs_events.song_id
where songs.id = $1
`

func (q *Queries) GetEventSongs(ctx context.Context, id uuid.UUID) ([]Song, error) {
	rows, err := q.db.Query(ctx, getEventSongs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TonalityRoot,
			&i.TonalityDetails,
			&i.SubcategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTypeEvents = `-- name: GetEventTypeEvents :many
select id, event_date, description, event_type_id from events
where event_type_id = $1
`

func (q *Queries) GetEventTypeEvents(ctx context.Context, eventTypeID uuid.UUID) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventTypeEvents, eventTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.EventDate,
			&i.Description,
			&i.EventTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTypes = `-- name: GetEventTypes :many
select id, name, description from event_types
`

func (q *Queries) GetEventTypes(ctx context.Context) ([]EventType, error) {
	rows, err := q.db.Query(ctx, getEventTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventType
	for rows.Next() {
		var i EventType
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongFiles = `-- name: GetSongFiles :many
select id, name, file_content, file_type, song_id from files
where song_id = $1
`

func (q *Queries) GetSongFiles(ctx context.Context, songID uuid.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, getSongFiles, songID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FileContent,
			&i.FileType,
			&i.SongID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongSubcategories = `-- name: GetSongSubcategories :many
select subcategories.id, subcategories.name, subcategories.category_id from subcategories
inner join songs
on subcategories.id = songs.subcategory_id
where songs.id = $1
`

func (q *Queries) GetSongSubcategories(ctx context.Context, id uuid.UUID) ([]Subcategory, error) {
	rows, err := q.db.Query(ctx, getSongSubcategories, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subcategory
	for rows.Next() {
		var i Subcategory
		if err := rows.Scan(&i.ID, &i.Name, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongs = `-- name: GetSongs :many
select id, name, tonality_root, tonality_details, subcategory_id from songs
`

func (q *Queries) GetSongs(ctx context.Context) ([]Song, error) {
	rows, err := q.db.Query(ctx, getSongs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TonalityRoot,
			&i.TonalityDetails,
			&i.SubcategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubcategorySongs = `-- name: GetSubcategorySongs :many
select id, name, tonality_root, tonality_details, subcategory_id from songs
where subcategory_id = $1
`

func (q *Queries) GetSubcategorySongs(ctx context.Context, subcategoryID string) ([]Song, error) {
	rows, err := q.db.Query(ctx, getSubcategorySongs, subcategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TonalityRoot,
			&i.TonalityDetails,
			&i.SubcategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTextFile = `-- name: GetTextFile :one
select id, name, file_content, file_type, song_id from files
where file_type = 'text' and song_id = $1
`

func (q *Queries) GetTextFile(ctx context.Context, songID uuid.UUID) (File, error) {
	row := q.db.QueryRow(ctx, getTextFile, songID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FileContent,
		&i.FileType,
		&i.SongID,
	)
	return i, err
}
