// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package model

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :exec
insert into events (id, date, description, event_type)
values ($1, $2, $3, $4)
`

type CreateEventParams struct {
	ID          string      `json:"id"`
	Date        pgtype.Date `json:"date"`
	Description pgtype.Text `json:"description"`
	EventType   interface{} `json:"event_type"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.Date,
		arg.Description,
		arg.EventType,
	)
	return err
}

const createWork = `-- name: CreateWork :exec
insert into works (id, composed_at, instrumentation, title)
values ($1, $2, $3, $4)
`

type CreateWorkParams struct {
	ID              string              `json:"id"`
	ComposedAt      pgtype.Date         `json:"composed_at"`
	Instrumentation InstrumentationName `json:"instrumentation"`
	Title           string              `json:"title"`
}

func (q *Queries) CreateWork(ctx context.Context, arg CreateWorkParams) error {
	_, err := q.db.Exec(ctx, createWork,
		arg.ID,
		arg.ComposedAt,
		arg.Instrumentation,
		arg.Title,
	)
	return err
}

const createWorkEvent = `-- name: CreateWorkEvent :exec
insert into works_events (work_id, event_id)
values ($1, $2)
`

type CreateWorkEventParams struct {
	WorkID  string `json:"work_id"`
	EventID string `json:"event_id"`
}

func (q *Queries) CreateWorkEvent(ctx context.Context, arg CreateWorkEventParams) error {
	_, err := q.db.Exec(ctx, createWorkEvent, arg.WorkID, arg.EventID)
	return err
}

const getEventTypeEvents = `-- name: GetEventTypeEvents :many
select id, date, description, event_type from events
where event_type = $1
`

func (q *Queries) GetEventTypeEvents(ctx context.Context, eventType interface{}) ([]Event, error) {
	rows, err := q.db.Query(ctx, getEventTypeEvents, eventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Description,
			&i.EventType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventWorks = `-- name: GetEventWorks :many
select id, composed_at, instrumentation, title from works
inner join works_events
on works.id = works_events.work_id
where works.id = $1
`

func (q *Queries) GetEventWorks(ctx context.Context, id string) ([]Work, error) {
	rows, err := q.db.Query(ctx, getEventWorks, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Work
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.ComposedAt,
			&i.Instrumentation,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubcategoryWorks = `-- name: GetSubcategoryWorks :many
select id, composed_at, instrumentation, title from works
where instrumentation = $1
`

func (q *Queries) GetSubcategoryWorks(ctx context.Context, instrumentation InstrumentationName) ([]Work, error) {
	rows, err := q.db.Query(ctx, getSubcategoryWorks, instrumentation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Work
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.ComposedAt,
			&i.Instrumentation,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkFiles = `-- name: GetWorkFiles :many
select id, name, file_path, work_id from files
where work_id = $1
`

func (q *Queries) GetWorkFiles(ctx context.Context, workID string) ([]File, error) {
	rows, err := q.db.Query(ctx, getWorkFiles, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FilePath,
			&i.WorkID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorks = `-- name: GetWorks :many
select id, composed_at, instrumentation, title from works
`

func (q *Queries) GetWorks(ctx context.Context) ([]Work, error) {
	rows, err := q.db.Query(ctx, getWorks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Work
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.ComposedAt,
			&i.Instrumentation,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
