// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package model

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type MusmgrEventType string

const (
	MusmgrEventTypeConcert     MusmgrEventType = "concert"
	MusmgrEventTypeExibition   MusmgrEventType = "exibition"
	MusmgrEventTypeCompetition MusmgrEventType = "competition"
	MusmgrEventTypeFestival    MusmgrEventType = "festival"
	MusmgrEventTypeOther       MusmgrEventType = "other"
)

func (e *MusmgrEventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MusmgrEventType(s)
	case string:
		*e = MusmgrEventType(s)
	default:
		return fmt.Errorf("unsupported scan type for MusmgrEventType: %T", src)
	}
	return nil
}

type NullMusmgrEventType struct {
	MusmgrEventType MusmgrEventType `json:"musmgr_event_type"`
	Valid           bool            `json:"valid"` // Valid is true if MusmgrEventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMusmgrEventType) Scan(value interface{}) error {
	if value == nil {
		ns.MusmgrEventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MusmgrEventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMusmgrEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MusmgrEventType), nil
}

type MusmgrInstrumentationName string

const (
	MusmgrInstrumentationNameChoir     MusmgrInstrumentationName = "choir"
	MusmgrInstrumentationNameSolo      MusmgrInstrumentationName = "solo"
	MusmgrInstrumentationNameChamber   MusmgrInstrumentationName = "chamber"
	MusmgrInstrumentationNameOrchestra MusmgrInstrumentationName = "orchestra"
	MusmgrInstrumentationNameOpera     MusmgrInstrumentationName = "opera"
	MusmgrInstrumentationNameMusical   MusmgrInstrumentationName = "musical"
	MusmgrInstrumentationNameAcusmatic MusmgrInstrumentationName = "acusmatic"
)

func (e *MusmgrInstrumentationName) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MusmgrInstrumentationName(s)
	case string:
		*e = MusmgrInstrumentationName(s)
	default:
		return fmt.Errorf("unsupported scan type for MusmgrInstrumentationName: %T", src)
	}
	return nil
}

type NullMusmgrInstrumentationName struct {
	MusmgrInstrumentationName MusmgrInstrumentationName `json:"musmgr_instrumentation_name"`
	Valid                     bool                      `json:"valid"` // Valid is true if MusmgrInstrumentationName is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMusmgrInstrumentationName) Scan(value interface{}) error {
	if value == nil {
		ns.MusmgrInstrumentationName, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MusmgrInstrumentationName.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMusmgrInstrumentationName) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MusmgrInstrumentationName), nil
}

type MusmgrEvent struct {
	ID          string          `json:"id"`
	Date        pgtype.Date     `json:"date"`
	Description pgtype.Text     `json:"description"`
	EventType   MusmgrEventType `json:"event_type"`
}

type MusmgrFile struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	WorkID string `json:"work_id"`
}

type MusmgrWork struct {
	ID              string                    `json:"id"`
	ComposedAt      pgtype.Date               `json:"composed_at"`
	Instrumentation MusmgrInstrumentationName `json:"instrumentation"`
	Title           string                    `json:"title"`
}

type MusmgrWorksEvent struct {
	WorkID  string `json:"work_id"`
	EventID string `json:"event_id"`
}
